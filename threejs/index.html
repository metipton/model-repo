<!DOCTYPE html>
<html>
	<head>
		<title> Three.js Crash Course</title>

		<style>
			body {margin: 0; }
			canvas {width: 100%; height: 100%;};
		</style>
	</head>

	<body>
		<h1>HEY THERE</h1>
		<script src="three.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="OBJLoader.js"></script>
		<script src="FBXLoader.js"></script>
		<script src="GLTFLoader.js"></script>
		<script src="inflate.min.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			window.addEventListener('resize', function()
			{
				var width = window.innerWidth;
				var height = window.innerHeight;
				renderer.setSize(width, height);
				camera.aspect = width / height;
				camera.updateProjectionMatrix();
			});

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.enablePan = false;
			controls.minDistance = 2.5;
			controls.maxDistance = 4.0;
			// How far you can orbit vertically, upper and lower limits.
			// Range is 0 to Math.PI radians.
			controls.minPolarAngle = 0; // radians
			controls.maxPolarAngle = Math.PI / 2; // radians

			//create shape

			camera.position.z = 4;

			//add the lighting to the scene
	        var light = new THREE.HemisphereLight( 0xffffff, 0x444444 );
	        light.position.set( 0, 200, 0 );
	        scene.add( light );
	        light = new THREE.DirectionalLight( 0xffffff );
	        light.position.set( 0, 200, 100 );
	        light.castShadow = true;
	        light.shadow.camera.top = 180;
	        light.shadow.camera.bottom = -100;
	        light.shadow.camera.left = -120;
	        light.shadow.camera.right = 120;
	        scene.add( light );


			//load 3d object
			var loader = new THREE.GLTFLoader( );
			//loader.setPath( 'models/3ds/portalgun/textures/' );

			 loadModel = () => {
					loader.load(
						'models/race1.glb',
						(object) => {
							convertMeshToSkinnedMesh(object);
							object.castShadow = true;
							object.scale.set( .010, .010, .010 );
							object.name = "race";
							scene.add( object );
							loader.load(
		   					 'models/pose2.fbx',
		   					 function ( object ) {
		   						 object.name = "pose";
		   						 scene.add(object);
		   						 addPoseToModel();
		   				 });
						},
						 null,
						(error) => {
							console.log(error);
						}
					);
			 }

			 loadModel();


			 convertMeshToSkinnedMesh = (object) => {
				 if( object === null || object === undefined) {
					 return;
				 }
				 let counter = 0;
				 object.traverse( function ( child ) {
					 if( child.material ) {
						 child.material = new THREE.MeshStandardMaterial( { color: 0xC0C0C0 } );

					 }
					 if ( child.isMesh ) {
						 object[counter] = new THREE.SkinnedMesh(child, new THREE.MeshStandardMaterial( { color: 0xC0C0C0 } ));
						 child.castShadow = true;
						 child.receiveShadow = true;
					 }
					 counter++;
				 });

				 for(let i = 0, count = object.children.length; i < count; i++) {
					 this.convertMeshToSkinnedMesh(object.children[i]);
				 }
			 }

			function createBones( root , array ) {
				if(root === null && root === undefined ) {
				  return;
				} else {
				  let bone = new THREE.Bone();

				  bone.position.set( root.position.x, root.position.y, root.position.z );
		          bone.name = root.name;
		          bone.setRotationFromQuaternion( root.quaternion );
		          bone.scale.set( root.scale.x, root.scale.y, root.scale.z );
				  if(root.parent !== null && root.parent !== undefined ) {
					  bone.parent = root.parent;
				  }
				  array.push(bone);

				  for(let i = 0, count = root.children.length; i < count; i++) {
					  createBones(root.children[i], array);
				  }
				  return;
				}
			}




			function addPoseToModel () {
				bones = [];

				 var model = scene.getObjectByName("race");
				 var pose = scene.getObjectByName("pose");
				 //model.updateMatrixWorld();
				 //pose.updateMatrixWorld();
				 console.log(model);
				 console.log(pose);
				 createBones( pose.children[0], bones );
				 console.log(bones);
				 addBonesToParents( bones );
				 model.children[0].add(bones[0]);
				 let skeleton = new THREE.Skeleton( bones, undefined, true );
				 //skeleton.position.y = -1;
				 model[1].bind(skeleton);
				 //model[1].pose();
				 let helper = new THREE.SkeletonHelper(model.children[0]);
				 console.log(helper);
				 scene.add(helper);
			}


			function addBonesToParents ( bones ) {
				for(let i = 0; i < bones.length; i++) {
					for(let j = 0; j < bones.length; j++) {
						if( bones[i].parent.name === bones[j].name ) {
							bones[j].add(bones[i]);
							break;
						}
					}
				}
			}


			console.log(scene);



			//create skybox
			var skyGeometry = new THREE.CubeGeometry(100, 100, 100);

			var cubeMaterials =
			[
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("skyboxes/bkg/blue/bkg1_back.png"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("skyboxes/bkg/blue/bkg1_front.png"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("skyboxes/bkg/blue/bkg1_bot.png"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("skyboxes/bkg/blue/bkg1_top.png"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("skyboxes/bkg/blue/bkg1_right.png"), side: THREE.DoubleSide}),
				new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("skyboxes/bkg/blue/bkg1_left.png"), side: THREE.DoubleSide})
			]

			var cube = new THREE.Mesh(skyGeometry, cubeMaterials);

			scene.add(cube);

			//game logic
			var update = function()
			{
				//cube.rotation.x += 0.01;
				//cube.rotation.y += 0.005;
			};

			//run game loop (update, render, repeat)
			var render = function()
			{
				renderer.render(scene, camera);
			};

			var animate = function() {

			}

			//run game loop
			var GameLoop = function()
			{
				requestAnimationFrame(GameLoop);
				update();
				render();
			};

			GameLoop();
		</script>
	</body>
</html>
